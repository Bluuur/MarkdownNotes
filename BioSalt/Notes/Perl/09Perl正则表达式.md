# 正则表达式

[toc]

正则表达式包括匹配、替换和转化。

+ 匹配：`m/.../` 也可以省略 `m`
+ 替换：`s/.../.../`
+ 转化：`tr/.../.../`

以上 `/` 定界符可以换成任意符号，只要成对出现。

以上三种形式一般都和 `=~` 或 `!~` 搭配使用，`=~` 表示匹配，`!~` 表示不匹配。

## 匹配操作符

匹配操作符 `m/<pattern>/` 用于匹配一个字符串语句或者一个正则表达式。

```perl
#!/usr/bin/perl
 
$bar = "I am runoob site. welcome to runoob site.";
if ($bar =~ /run/){
   print("匹配\n");
}else{
   print("不匹配\n");
}
```

### 模式匹配修饰符

| 修饰符 |                             描述                             |
| :----: | :----------------------------------------------------------: |
|  `i`   |                      忽略模式中的大小写                      |
|  `m`   |                           多行模式                           |
|  `o`   |                          仅赋值一次                          |
|  `s`   | 单行模式（全部文本视作一行）<br>`.` 除了匹配任意字符外<br>还会匹配 `\n`（默认不匹配） |
|  `x`   |                       忽略模式中的空白                       |
|  `g`   |                           全局匹配                           |
|  `cg`  |              全局匹配失败后，允许再次查找匹配串              |

这些模式匹配修饰符写在表达式定界符的后面，用来改变默认的匹配行为，比如 `$str =~ /<pattern>/i`

---

关于 `/s`：

```perl
$_ = "I saw Barney\ndown at the bowling alley\nwith Fred\n last  night.\n"

if (/Barney.*Fred/s) {
	print("匹配\n");
}
```

如果没有 `/s` 修饰符的话，上面的匹配就会失效，因为前后两个字符不在同一行。

---

关于 `/x`：

`/x` 会忽略模式里的空格，可以使用这个修饰符提高模式的可读性。例如：`/-? [0-9] \.? [0-9]*/x`。如果在使用了 `/x` 的同时需要匹配空格，可以通过转义的方式实现：在空格前面加上反斜线或者使用 `\t` `\s`

Perl 会忽略模式中的注释，可以使用 `#` 对模式注释。

```perl
/
	-?		# 一个可有可无的减号
	[0-9]+	# 小数点前必须出现一个或多个数字
	\.?		# 一个可有可无的小数点
	[0-9]*	# 小数点后面的数字可有可无
/x
```

## 锚位

默认情况下，如果给定模式不匹配字符串的开头，就会顺移到下一个字符继续尝试。而通过给定锚位，可以让模式仅在字符串指定位置匹配。

### `\A`

`\A` 锚位匹配字符串的绝对开头，也就是说，如果开头位置上不匹配，不会顺移到下一个位置继续尝试，比如这个模式判断字符串是否以 `https` 开头：`m{\Ahttps?://}`

### `\z`

`\z` 锚位匹配字符串的绝对末尾（串尾），比如：`m{\.png\z}i`。

绝对串尾识别最后的换行符，一般在试用前需要去掉最后的换行符，而 `\Z` 允许串尾出现换行符。

### 行首与行尾

如果需要定位行首和行尾，可以使用 `/m` 修饰符和 `$` `^`，比如：`/fred$m/` 匹配行尾的 `fred`；`/^barney/m` 匹配行首的 `barney`。

### 单词锚位

锚位不局限于字符串首尾，`\b` 是单词边界锚位，匹配任何单词的首尾，比如：`/\bfred\b/` 匹配 `fred`，但不匹配 `frederick`。这里的「单词」不只是一般的英文单词，还包括数字与下划线。

有时候也只用到一个单词锚位，比如：`/\bhunt/` 匹配 `hunt` `hunting`，而排除了 `shunt`。

## 正则表达式变量

Perl 处理完后会给匹配到的值存在三个特殊变量名：

+ `` $` ``：匹配部分的前一部分字符串
+ `$&`：匹配的字符串
+ `$'`：还没有匹配的剩余字符串

如果将这三个变量放在一起，可以得到原始字符串。

## 模式中的内插

正则表达式内部可以进行双引号形式的内插：

```perl
#!/usr/bin/perl -w
my $what = "larry"
while (<>) {
	if (/\A($waht)/) {
		print("We saw $what in beginning of $_");
	}
}
```

## 捕获变量

圆括号出现的地方一般都会触发正则表达式引擎捕获匹配到的字符串。捕获组会把匹配圆括号中模式的字符串保存到相应的地方。如果不止一个括号，也就不止一个捕获组。每个捕获组包含的都是原始字符串中的内容，而不是模式本身。我们可以通过反向引用取得这些捕获内容，但也可以在匹配操作结束后立即通过相应的捕获变量取得这些内容。

捕获变量保存的是字符串，那就说明它是标量变量。在 Perl 里面，它们的名称就是 `$1` 和 `$2` 这样的形式。模式中有多少个捕获括号，就有多少个对应名称的捕获变量可用。所以，变量 `$4` 的意思就是模式中第 4 对括号所匹配的字符串内容，这个内容和模式 运行期间反向引用\4所表示的内容是一样的。

+ `/\s(\[a-zA-Z]+,/)` 捕获空白符和逗号之间的单词
+ `/(\S+) (\S+) (\S+)/` 匹配三个单词

如果字符串完全不符合模式要求， 得到的捕获变量为空。

### 捕获变量的存续期

捕获变量一般能存货到下次成功匹配为止，如果第二次匹配失败，则不改动上次匹配成功时捕获的内容。

### 不捕获模式

Perl 的正则表达式允许使用圆括号分组但不进行捕获，书写时在左括号后面加上 `?:`，表示这一对圆括号是为了分组而存在。比如：`/(?:bronto)?saurus (steak|burger)/` 会将匹配到的 `steak|burger` 赋值给 `$1$`。

### 命名捕获

可以利用圆括号的捕获功能提取特定字符串并保存到诸如 `$1`、`$2` 这样的变量中。不过就算是较为简单的模式，要维护数字变量和圆括号之间的对应关系也比较困难。

```perl
my $names = "Fread or Barney";
if ($names =~ m/(\w+) and (\w+)/) {
	say("I saw $1 and $2");
}
```

这里 `say ` 不会输出，因为实际变量中给出的是 `or`，而模式中的是 `and`，可以加入择一匹配来匹配 `or` 或 `and` 中的一个，在使用择一匹配时需要用圆括号表示候选列表范围：

```perl
my $names = "Fread or Barney";
if ($names =~ m/(\w+) (and|or) (\w+)/) {
	say("I saw $1 and $2");
}
```

这时 `$2` 变量中拿到的是择一匹配部分中的内容，原本希望拿到的第二个变量放到了 `$3` 中。这个时候可以使用不捕获也括号的写法：`m/(\w+) (?:and|or) (\w+)/`。

但是括号的序号仍需要另外记忆，可以对捕获内容命名来避免。命名捕获后，最终捕获到的内容会保存在特殊哈希 `%+` 中，key 为捕获用的特殊标签， value 为被捕获的字符串。写法为`(?<LABLE>PATTERN)`，比如：

```perl
my $names = "Fread or Barney";
if ($names =~ m/(?<name1>\w+) (?:and|or) (?<name2>\w+)/) {
	say("I saw $+{name1} and $+{name2}");
}
```

## 通用量词

+ `*` 匹配 0 到任意次
+ `+` 匹配 1 到任意次
+ `?` 匹配 0 到 1 次

此外还可以使用 `{}` 指定具体的重复次数，`/a{5,15}/` 会匹配出现 5 到 15 次的 a，如果 a 出现超过 15 次，则只匹配前 15 个。

如果省略第二个数字但保留逗号，则表示匹配次数没有上限。所以，`/(fred){3,}/`这个模式会匹配重复出现 3 次以上的 fred（在每个 fred 之间不能有空格等额外字符）。

如果同时省略逗号与上限次数，那么花括号里的数字就表示一个固定的次数： `/\w{8}/` 会匹配正好有 8 个单词字符的字符串（或许是大型字符串里的一部分）。

## 替换

使用 `s/.../.../` 替换（substitution）。

```perl
$str = "He's out bowling with Barney tonight.";
$str =~ s/Barney/Fred/;
print("$str\n");
# He's out bowling with Fred tonight.

$str =~ s/with (\w+)/against $1's team/;
print("$str\n");
# He's out bowling against Fred's team tonight.
```

### 使用 `/g` 进行全局替换

`s///` 仅进行一次替换，使用 `/g` 进行所有可能的、不重复的替换。

常见的全局替换是缩减空白：

```perl
$str = "Input  data\t may have    extra whitespace.";
$str =~ s/\s+/ /g;
print("$str\n");
# Input data may have extra whitespace.
```

```perl
$_ = "/users/zhangzd/data/perl/test.pl";
s#^.*/##s; # 删除所有 Unix 风格的路径
print; # test.pl
```

### 无损替换

如果需要同事保留原始字符串和替换后的字符串，可以先复制一份再替换。

```perl
my $original = "Fred ate 1 rib";
my $copy = $original;
$copy =~ s/\d+ ribs?/10 ribs/;
```

也可以并作一步：

```perl
(my $copy = $original) s/\d+ ribs?/io ribs/;
```

先将 `$original` 赋值给 `$copy` 然后对 `$copy` 替换。

---

也可以使用 `/r` 修饰符：

```perl
my $copy = $original =~ s/\d+ ribs?/10 ribs/r;
```

这里是先进行原字符串的替换，但不改变原字符串的值，然后将替换后的结果赋值给 `$copy`。

### 大小写转换

+ `\U`：将该转义符后面的所有字符都转换为大写。
+ `\L`：将该转义符后面的所有字符都转换为小写。
+ `\u` & `\l`：仅转换该转义符后面的第一个字符。

---

使用 `\E` 结束转换：

```perl
$_ = "I saw Barney with Fred.";
s/(\w+) with (\w+)/\U$2\E with $1/i;
print;
# I saw FRED with Barney.
# 如果不使用 \E 会输出：
# I saw FRED WITH BARNEY.
```

---

可以将这些转义符并用：

比如 `\u\L` 表示首字母转换为大写，后续字符小写。也可以写作 `\L\u` 可以实现同样的效果。

```perl
s/(fred|barney)/\u\L$l/ig;
```

除了可以在替换时使用，还可以在任何双引号的字符串中使用。

