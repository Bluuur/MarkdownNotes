# Redis 键 key

+   `keys *` 查看当前库所有key (匹配: `keys *1`)
+   `set <key> <vlaue>` 添加key
+   `exist <key>` 判断某个key是否存在
+   `type <key>` 查看key的类型
+   `del <key>` 删除指定的key数据
+   `unlink <key>` 根据value选择非阻塞删除 
    +   仅将keys从keyspace元数据中删除,真正的删除会在后续异步操作
+   `expire <key> <second>` 为给定的key设置过期时间(10秒)
    +   没有设置的话永不过期
+   `ttl <key>` 查看还有多少秒过期
    +   `ttl` = time to live 
    +   `-1` 表示永不过期
    +   `-2` 表示已过期
+   `select <num>` 命令切换数据库
+   `dbsize` 查看当前数据库的key数量
+   `rename <key> <newkey>` 修改key的名称
+   `renamenx <key> <newkey>`   仅当 newkey 不存在时, 将 key 改名为 newkey 
+    `flushdb` 清空当前库
+   `flushall`  通杀全部库

# Redis 字符串 String

## 特点

+   `String`是Redis最基本的类型,你可以理解成与Memcached一模一样的类型,一个`key`对应一个`value`.
+   `String`类型是二进制安全的.意味着Redis的`string`可以包含任何数据.比如jpg图片或者序列化的对象.
+   `String`类型是Redis最基本的数据类型,一个Redis中字符串`value`最多可以是512M.
+   设置相同的key值 会覆盖之前的值

## 常用命令

+   `get <key>` 查询对应的`key`值
+   `getrange <key> <start> <end>` 返回key字符串值的子串
    `start` 从0开始, 包含 `start` 和 `end`
+   `append <key> <value> `将给定的`<value>`追加到原值的末尾 会返回追加后的字符串长度
+   `strlen <key>` 获得值的长度
+   `setnx <key> <value>` 只有在`key`不存在时 设置`key`的值
+   `incr <key>` 将key中储存的数字值加1 只能对数字值操作, 如果为空, 新增值为1 会返回增加后的值
+   `decr <key>` 将key中储存的数字值减1 只能对数字值操作, 如果为空, 新增值为-1 会返回减小后的值
+   `incrby` / `decrby <key> <步长>` 将key中储存的数字值增减 自定义步长 

>   原子操作
>
>   所谓原子操作是指不会被线程调度机制打断的操作;这种操作一旦开始,就一直运行到结束,中间不会有任何context switch (切换到另一个线程)
>
>   +   在单线程中, 能够在单条指令中完成的操作都可以认为是“原子操作”, 因为中断只能发生于指令之间
>   +   在多线程中, 不能被其他进程(线程)打断的操作就叫原子操作
>
>   Redis 单命令的原子性主要得益于Redis的单线程

+   `mset <key1><value1><key2><value2>...` 同时设置一个或多个 key-value 对 
    +   设置的多个key中 如果有一个key已经存在 那么这些值都不会被设置成功 (原子性) Atomicity 
        操作这些指令时，要么全部执行成功，要么全部不执行。只要其中一个指令执行失败，所有的指令都执行失败，数据进行回滚，回到执行指令前的数据状态。
+   `mget <key1><key2><key3>...` 同时获取多个 value
+   `setex <key> <second> <value>` 设置键值对的同时 设置过期时间
+   `get <key> <newvalue>` 设置新值的同时 获取旧值

## 底层数据结构

Redis String 的底层数据结构为简单动态字符串 (Simple Dynamic String) 内部结构实现上类似于 Java 的A rrayList 采用预分配冗余空间的方式来减少内存的频繁分配

```C
struct sdshdr{
    int len;//buf数组已使用的字节，即SDS保存的字符串长度
    int free;//未使用的字节长度
    char buf[];//保存字符串的字节数组
}
```

如要保存`redis`这几个字符，则其SDS结构为：

```C
buf[]:  'r','e','d','i','s','\0'
 len=5;
 free=0;
```

### SDS特性

#### 常数复杂度获取字符串长度

因为使用`len`记录了自身的长度，可以不像C字符串一样从头遍历进行计数获取。

#### 避免缓冲区溢出

SDS在需要修改时，会先检查空间是否满足大小，如果不满足，则先扩展至所需大小再进行修改操作。

减少修改字符串的重分配次数

#### 空间预分配

如果SDS需要扩展，程序在给SDS分配所需空间后，还会分配额外的未使用空间。

+   如果修改后`len`长度小于1MB

则给SDS分配所需的空间后，再分配同样大小的未使用空间。

如`len`长度为1字节，修改后为3字节，则分配2字节空间保证需求，再分配3字节未使用空间进行预分配，下次再进行修改时，如果预分配的3字节够，就不会再进行空间分配操作，而是直接使用，

此时`buf[]`的长度为$3+3+1$，对应的`len=3`，`free=3,buf[]={‘1’,‘2’,‘3’,‘\0’,‘’,‘’,‘’}`，最后就多了3个预分配的空间。

+   如果修改后`len`长度大于1MB

分配满足需求的空间后再额外分配1MB预分配空间。

如果当前长度为800，修改后的`len`为1100>1024=1MB，则分配300字节空间满足需求，再分配1MB空间作为预分配空间。此时`len=1100+1024+1`，`free=1024`

#### 惰性释放

如果需要缩短字符串，不会立即回收多余的空间，而是用free记录剩余的空间，以备下次扩展时直接使用，避免再次分配。

如有字符串`redis`，`buf[]={'r','e','d','i','s','\0'}`，如果只想要red三个字符，则`buf`结构为：`buf[]={‘r’,‘e’,‘d’, ‘ ’ , ‘ ’, ‘\0’ }`，多余的两个长度的空间不会进行回收，此时使用free=2记录空闲空间。如果再变成`redis`字符串，则直接在多的空间上进行修改，不会进行空间分配操作。

#### 二进制安全

可以包含任何数据，包括字符串、序列化对象、图片等，但字符串大小上限为512MB。

# Redis 哈希 Hash

# Redis 列表 List

## 特点

单键多值

Redis列表是简单的字符串列表, 按照插入顺序排序. 你可以添加一个元素到列表的头部(左边)或者尾部(右边).

它的底层实际是个双向链表, 对两端的操作性能很高, 通过素引下标的操作中间的节点性能会较差.

![image-20211010150735011](image/image-20211010150735011.png)

## 常用命令

+   `lpush/rpush <key><value1><value2><value3>...` 从左边/右边插入一个或多个值
    可以使用一个命令把多个元素 `push` 进入列表,只需在命令末尾加上多个指定的参数.元素是从最左端的到最右端的、一个接一个被插入到 list 的头部. 所以对于这个命令例子 `LPUSH mylist a b c`, 返回的列表是 c 为第一个元素, b 为第二个元素, a 为第三个元素.7
+   `lpop/rpop <key>` 从左边/右边弹出一个值
+   `rpoplpush <source> <destination>` 移除列表的最后一个元素, 并将该元素添加到另一个列表并返回
+   `lrange <key> <start> <stop>` 获取列表指定范围内的元素 `0`表示左边第一个,`-1`表示右边第一个, `0 -1`表示获取所有值
+   `lindex <key> <index>` 通过索引获取列表中的元素(从左到右) 下标从0开始
+   `llen <key>` 获取列表的长度
+   `linsert <keu> before/after <value> <newvalue>`  在`value`的前面/后面插入`<newvalue>`  `value`和`newvalue` 需要打引号
+   `lrem <key> <n> <value>` 从左边删除`n`个`value` 
+   `lset <key> <index> <value>` 将`<key>`下标为`index`的值替换为`value`

## 底层数据结构

List的数据结构为快速链表 `quickList`

首先在列表元素较少的情况下会使用一块连续的内存存储,这个结构是压缩列表 `zipList`

它将所有的元素紧挨着一起存储,分配的是一块连续的内存

当数据量比较多的时候才会改成`quickList`.

因为普通的链表需要的附加指针空间太大,会比较浪费空间.比如这个列表里存的只是int类型的数据,结构上还需要两个额外的指针`prev`和`next`

![image-20211010155031573](image/image-20211010155031573.png)

Redis将链表和`zipList`结合起来组成了`quickList`, 也就是将多个`zipList`使用双向指针串起来使用. 这样既满足了快速的插入删除性能, 又不会出现太大的空间冗余..

# Redis 集合 Set

## 特点

Redis `set`对外提供的功能与`list`类似是一个列表的功能, 特殊之处在于`set`是可以自动排重的, 当你需要存储一个列表数据, 又不希望出现重复数据时,`set`是一个很好的选择, 并且`set`提供了判断某个成员是否在一个`set`集合内的重要接口, 这个也是`list`所不能提供的.

Redis的`Set`是`String`类型的无序集合.它底层其实是一个`value`为`null`的`hash`表,所以添加,删除,查找的复杂度都是 $O(1)$.

一个算法,随着数据的增加,执行时间的长短,如果是 $O(1)$, 数据增加,查找数据的时间不变

## 常用命令

+   `sadd <key> <value1> <value2>...` 将一个或多个`member`元素加入到集合`key`中, 已经存在的`member`元素将被忽略
+   `smembers <key>` 取出该集合的所有值
+   `sismember <key> <value>` 判断集合`key`是否为含有该`<value>`值, 有则返回`1`,没有则返回`0`

