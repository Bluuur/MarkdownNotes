# Redis 键 key

+   `keys *` 查看当前库所有key (匹配: `keys *1`)
+   `set <key> <vlaue>` 添加key
+   `exist <key>` 判断某个key是否存在
+   `type <key>` 查看key的类型
+   `del <key>` 删除指定的key数据
+   `unlink <key>` 根据value选择非阻塞删除 
    +   仅将keys从keyspace元数据中删除,真正的删除会在后续异步操作
+   `expire <key> <second>` 为给定的key设置过期时间(10秒)
    +   没有设置的话永不过期
+   `ttl <key>` 查看还有多少秒过期
    +   `ttl` = time to live 
    +   `-1` 表示永不过期
    +   `-2` 表示已过期
+   `select <num>` 命令切换数据库
+   `dbsize` 查看当前数据库的key数量
+   `rename <key> <newkey>` 修改key的名称
+   `renamenx <key> <newkey>`   仅当 newkey 不存在时, 将 key 改名为 newkey 
+    `flushdb` 清空当前库
+   `flushall`  通杀全部库

# Redis 字符串 String

## 特点

+   `String`是Redis最基本的类型,你可以理解成与Memcached一模一样的类型,一个`key`对应一个`value`.
+   `String`类型是二进制安全的.意味着Redis的`string`可以包含任何数据.比如jpg图片或者序列化的对象.
+   `String`类型是Redis最基本的数据类型,一个Redis中字符串`value`最多可以是512M.
+   设置相同的key值 会覆盖之前的值

## 操作

+   `get <key>` 查询对应的`key`值
+   `getrange <key> <start> <end>` 返回key字符串值的子串
    `start` 从0开始, 包含 `start` 和 `end`
+   `append <key> <value> `将给定的`<value>`追加到原值的末尾 会返回追加后的字符串长度
+   `strlen <key>` 获得值的长度
+   `setnx <key> <value>` 只有在`key`不存在时 设置`key`的值
+   `incr <key>` 将key中储存的数字值加1 只能对数字值操作, 如果为空, 新增值为1 会返回增加后的值
+   `decr <key>` 将key中储存的数字值减1 只能对数字值操作, 如果为空, 新增值为-1 会返回减小后的值
+   `incrby` / `decrby <key> <步长>` 将key中储存的数字值增减 自定义步长 

>   原子操作
>
>   所谓原子操作是指不会被线程调度机制打断的操作;这种操作一旦开始,就一直运行到结束,中间不会有任何context switch (切换到另一个线程)
>
>   +   在单线程中, 能够在单条指令中完成的操作都可以认为是“原子操作”, 因为中断只能发生于指令之间
>   +   在多线程中, 不能被其他进程(线程)打断的操作就叫原子操作
>
>   Redis 单命令的原子性主要得益于Redis的单线程

+   `mset <key1><value1><key2><value2>...` 同时设置一个或多个 key-value 对 
    +   设置的多个key中 如果有一个key已经存在 那么这些值都不会被设置成功 (原子性) Atomicity 
        操作这些指令时，要么全部执行成功，要么全部不执行。只要其中一个指令执行失败，所有的指令都执行失败，数据进行回滚，回到执行指令前的数据状态。
+   `mget <key1><key2><key3>...` 同时获取多个 value
+   `setex <key> <second> <value>` 设置键值对的同时 设置过期时间
+   `get <key> <newvalue>` 设置新值的同时 获取旧值

## 底层数据结构

Redis String 的底层数据结构为简单动态字符串 (Simple Dynamic String)

```C
struct sdshdr{
    int len;//buf数组已使用的字节，即SDS保存的字符串长度
    int free;//未使用的字节长度
    char buf[];//保存字符串的字节数组
}
```

如要保存`redis`这几个字符，则其SDS结构为：

```C
buf[]:  'r','e','d','i','s','\0'
 len=5;
 free=0;
```

### SDS特性

#### 常数复杂度获取字符串长度

因为使用`len`记录了自身的长度，可以不像C字符串一样从头遍历进行计数获取。

#### 避免缓冲区溢出

SDS在需要修改时，会先检查空间是否满足大小，如果不满足，则先扩展至所需大小再进行修改操作。

减少修改字符串的重分配次数

#### 空间预分配

如果SDS需要扩展，程序在给SDS分配所需空间后，还会分配额外的未使用空间。

如果修改后`len`长度小于1MB

则给SDS分配所需的空间后，再分配同样大小的未使用空间。

如`len`长度为1字节，修改后为3字节，则分配2字节空间保证需求，再分配3字节未使用空间进行预分配，下次再进行修改时，如果预分配的3字节够，就不会再进行空间分配操作，而是直接使用，

此时`buf[]`的长度为$3+3+1$，对应的`len=3`，`free=3,buf[]={‘1’,‘2’,‘3’,‘\0’,‘’,‘’,‘’}`，最后就多了3个预分配的空间。

如果修改后`len`长度大于1MB

分配满足需求的空间后再额外分配1MB预分配空间。

如果当前长度为800，修改后的`len`为1100>1024=1MB，则分配300字节空间满足需求，再分配1MB空间作为预分配空间。此时`len=1100+1024+1`，`free=1024`

#### 惰性释放

如果需要缩短字符串，不会立即回收多余的空间，而是用free记录剩余的空间，以备下次扩展时直接使用，避免再次分配。

如有字符串`redis`，`buf[]={'r','e','d','i','s','\0'}`，如果只想要red三个字符，则`buf`结构为：`buf[]={‘r’,‘e’,‘d’, ‘ ’ , ‘ ’, ‘\0’ }`，多余的两个长度的空间不会进行回收，此时使用free=2记录空闲空间。如果再变成`redis`字符串，则直接在多的空间上进行修改，不会进行空间分配操作。

#### 二进制安全

可以包含任何数据，包括字符串、序列化对象、图片等，但字符串大小上限为512MB。

# Redis 哈希 Hash

