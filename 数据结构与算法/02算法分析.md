[TOC]

# 算法分析

前面我们已经介绍了，研究算法的最终目的就是如何花更少的时间，如何占用更少的内存去完成相同的需求，并且
也通过案例演示了不同算法之间时间耗费和空间耗费上的差异，但我们并不能将时间占用和空间占用量化，因此，
接下来我们要学习有关算法时间耗费和算法空间耗费的描述和分析。有关算法时间耗费分析，我们称之为算法的时
间复杂度分析，有关算法的空间耗费分析，我们称之为算法的空间复杂度分析。

## 算法的时间复杂度分析

我们要计算算法时间耗费情况，首先我们得度量算法的执行时间，那么如何度量呢？

### 事后分析估算方法

比较容易想到的方法就是我们把算法执行若干次，然后拿个计时器在旁边计时，这种事后统计的方法看上去的确不
错，并且也并非要我们真的拿个计算器在旁边计算，因为计算机都提供了计时的功能。这种统计方法主要是通过设
计好的测试程序和测试数据，利用计算机计时器对不同的算法编制的程序的运行时间进行比较，从而确定算法效率
的高低，但是这种方法有很大的缺陷：必须依据算法实现编制好的测试程序，通常要花费大量时间和精力，测试完
了如果发现测试的是非常糟糕的算法，那么之前所做的事情就全部白费了，并且不同的测试环境(硬件环境)的差别
导致测试的结果差异也很大。

```java
public static void main(String[] args) {
    long start = System.currentTimeMillis();
    int sum = 0;
    int n = 100;
    for (int i = 1; i <= n; i++) {
        sum += i;
    }
    System.out.println("sum=" + sum);
    long end = System.currentTimeMillis();
    System.out.println(end - start);
}
```

### 事前分析估算方法

在计算机程序编写前，依据统计方法对算法进行估算，经过总结，我们发现一个高级语言编写的程序程序在计算机
上运行所消耗的时间取决于下列因素

1.   算法采用的策略和方案
2.   编译产生的代码质量
3.   问题的输入规模(所谓的问题输入规模就是输入量的多少)
4.   机器执行指令的速度

由此可见，抛开这些与计算机硬件、软件有关的因素，一个程序的运行时间依赖于算法的好坏和问题的输入规模。
如果算法固定，那么该算法的执行时间就只和问题的输入规模有关系了。

我么再次以之前的求和案例为例，进行分析。

需求
计算1到100的和

第一种解法

```java
/**
     * 如果输入量为n为1，则需要计算1次;
     * 如果输入量n为1亿，则需要计算1亿次;
     */
public static void main(String[] args) {
    //执行1次
    int sum = 0;
    //执行1次
    int n = 100;
    //执行了n+1次
    for (int i = 1; i <= n; i++) {
        //执行了n次
        sum += i;
    }
    System.out.println("sum=" + sum);
}
```

第二种解法

```java
/**
  * 如果输入量为n为1，则需要计算1次
  * 如果输入量n为1亿，则需要计算1次
  */
public static void main(String[] args) {
    int sum = 0;//执行1次
    int n = 100;//执行1次
    sum = (n + 1) * n / 2;//执行1次  
    System.out.println("sum=" + sum);
}
```

因此，当输入规模为 $n$ 时，第一种算法执行了 $1+1+(n+1)+n=2n+3$ 次；第二种算法执行了 $1+1+1=3$ 次。如果我们把第一种算法的循环体看做是一个整体，忽略结束条件的判断，那么其实这两个算法运行时间的差距就是 $n$ 和 $1$ 的差距。
为什么循环判断在算法 $1$ 里执行了 $n+1$ 次，看起来是个不小的数量，但是却可以忽略呢？

我们来看下一个例子：需求：
计算 $100个1+100个2+100个3+\cdots 100个100$ 的结果
代码：

```java
public static void main(String[] args) {
    int sum = 0;
    int n = 100;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            sum += i;
        }
    }
    System.out.println("sum=" + sum);
}
```



上面这个例子中，如果我们要精确的研究循环的条件执行了多少次，是一件很麻烦的事情，并且，由于真正计算和的代码是内循环的循环体，所以，在研究算法的效率时，我们只考虑核心代码的执行次数，这样可以简化分析。

我们研究算法复杂度，侧重的是当输入规模不断增大时，算法的增长量的一个抽象(规律)，而不是精确地定位需要执行多少次，因为如果是这样的话，我们又得考虑回编译期优化等问题，容易主次跌倒。

我们不关心编写程序所用的语言是什么，也不关心这些程序将跑在什么样的计算机上，我们只关心它所实现的算法。这样，不计那些循环索引的递增和循环终止的条件、变量声明、打印结果等操作，最终在分析程序的运行时间时，最重要的是把程序看做是独立于程序设计语言的算法或一系列步骤。我们分析一个算法的运行时间，最重要的就是把核心操作的次数和输入规模关联起来。

![image-20211009101214276](image/image-20211009101214276.png)

### 函数渐进增长

#### 概念

给定两个函数 $f(n)$ 和 $g(n)$ , 如果存在一个整数 $N,$ 使得对于所有的 $n>N,f(n)$ 总是比 $g(n)$ 大 , 那么我们说 $f(n)$ 的增长渐近快于 $g(n)$ 

概念似乎有点艰涩难懂，那接下来我们做几个测试。

测试一：
	假设四个算法的输入规模都是$n$

1.	算法 $A1$ 要做 $2n+3$ 次操作,可以这么理解先执行 $n$ 次循环,执行完毕后,再有一个 $n$ 次循环,最后有 $3$ 次运算
2.	算法 $A2$ 要做 $2n$ 次操作
3.	算法 $B1$ 要做 $3n+1$ 次操作,可以这个理解:先执行 $n$ 次循环,再执行一个 $n$ 次循环,再执行一个 $n$ 次循环,最后有1次运算.
4.	算法 $B2$ 要做 $3n$ 次操作;


| 输入规模 | 算法 $A1(2n+3)$ 执行次数 | 算法 $A2(2n)$ 执行次数 | 算法 $B1(3n+1)$ 执行次数 | 算法 $B2(3n)$ 执行次数 |
| :---: | :---: | :---: | :---: | :---: |
| $n=1$ | $5$ | $2$ | $4$ | $3$ |
| $n=2$ | $7$ | $4$ | $7$ | $6$ |
| $n=3$ | $6$ | $10$ | $9$ | $9$ |
| $n=10$ | $20$ | $31$ | $30$ | $30$ |
| $n=100$ | $9$ | $200$ | $301$ | $300$ |

![image-20211009103121553](image/image-20211009103121553.png)

通过数据表格，比较算法A1和算法B1：
  当输入规模 $n=1$ 时，A1需要执行5次，B1需要执行4次，所以A1的效率比B1的效率低；
  当输入规模 $n=2$ 时，A1需要执行7次，B1需要执行7次，所以A1的效率和B1的效率一样；
  当输入规模 $n>2$ 时，A1需要的执行次数一直比B1需要执行的次数少，所以A1的效率比B1的效率高；   
所以我们可以得出结论：

**当输入规模 $\boldsymbol{n>2}$ 时，算法 A1 的渐近增长小于算法 B1 的渐近增长**

通过观察折线图，我们发现，随着输入规模的增大，算法A1和算法A2逐渐重叠到一块，算法B1和算法B2逐渐重叠到一块，所以我们得出结论：

**随着输入规模的增大，算法的常数操作可以忽略不计**

测试二
假设四个算法的输入规模都是 n

1.	算法C1需要做 $4n+8$ 次操作
2.	算法C2需要做 $n$ 次操作
3.	算法D1需要做 $2n^2$ 次操作
4.	算法D2需要做 $n^2$ 次操作

![image-20211009103320746](image/image-20211009103320746.png)

通过数据表格，对比算法C1和算法D1：

当输入规模 $n\leq 3$ 时，算法C1执行次数多于算法D1，因此算法C1效率低一些 
当输入规模 $n>3$ 时，算法C1执行次数少于算法D1，因此，算法D2效率低一些，   所以，总体上，算法C1要优于算法D1.

通过折线图，对比对比算法C1和C2：
	随着输入规模的增大，算法C1和算法C2几乎重叠

通过折线图，对比算法C系列和算法D系列：
	随着输入规模的增大，即使去除 $n^2$ 前面的常数因子，D系列的次数要远远高于C系列。  

因此，可以得出结论：
  随着输入规模的增大，与最高次项相乘的常数可以忽略

测试三：
假设四个算法的输入规模都是 $n$

​	算法E1:
 	 $2n^2+3n+1$

​	算法E2：
 	 $n^2$

​	算法F1：
 	 $2n^3+3n+1$

​	算法F2：
 	 $n^3$

那么上述算法，哪个更快一些？

![image-20211009103504866](image/image-20211009103504866.png)

通过数据表格，对比算法E1和算法F1：

  当n=1时，算法E1和算法F1的执行次数一样；
  当n>1时，算法E1的执行次数远远小于算法F1的执行次数；

所以算法E1总体上是由于算法F1的

通过折线图我们会看到，算法F系列随着n的增长会变得特块，算法E系列随着n的增长相比较算法F来说，变得比较慢，所以可以得出结论

​	**最高次项的指数大的，随着n的增长，结果也会变得增长特别快**

测试四
假设五个算法的输入规模都是 $n$

​	  算法G
​	  $n^3$

​	  算法H
​	  $n^2$

​	  算法I
​	  $n$

​	  算法J
​	  $\log n$

​	  算法K
​	  $1$

那么上述算法，哪个效率更高呢？

![image-20211009103626987](image/image-20211009103626987.png)

通过观察数据表格和折线图，很容易可以得出结论

​		算法函数中 $n$ 最高次幂越小，算法效率越高

总上所述，在我们比较算法随着输入规模的增长量时可以有以下规则

1.	算法函数中的常数可以忽略
2.	算法函数中最高次幂的常数因子可以忽略
3.	算法函数中最高次幂越小 算法效率越高

### 算法时间复杂度
#### 大O记法
定义

在进行算法分析时，语句总的执行次数 $T(n)$ 是关于问题规模 $n$ 的函数，进而分析 $T(n)$ 随着 $n$ 的变化情况并确定 $T(n)$ 的量级。算法的时间复杂度，就是算法的时间量度，记作 $:T(n)=O(f(n)).$ 它表示随着问题规模 $n$ 的增大，算法执行时间的增长率和 $f(n)$ 的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度，其中 $f(n)$ 是问题规模 $n$ 的某个函数

  在这里，我们需要明确一个事情：执行次数 = 执行时
  用大写 $O()$ 来体现算法时间复杂度的记法，我们称之为大O记法. 一般情况下 , 随着输入规模 $n$ 的增大 $,T(n)$ 增长最慢的算法为最优算法。

下面我们使用 $O$ 表示法来表示一些求和算法的时间复杂度

算法一

```java
public static void main(String[] args) {
    int sum = 0;//执行1次
    int n = 100;//执行1次
    sum = (n + 1) * n / 2;//执行1次
    System.out.println("sum=" + sum);
}
```

算法二

```java
public static void main(String[] args) {
    int sum = 0;//执行1次
    int n = 100;//执行1次
    for (int i = 1; i <= n; i++) {
        sum += i;//执行了n次
    }
    System.out.println("sum=" + sum);
}
```

算法三

```java
public static void main(String[] args) {
    int sum = 0;//执行1次
    int n = 100;//执行1次
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            sum += i;//执行n^2次
        }
    }
    System.out.println("sum=" + sum);
}
```

如果忽略判断条件的执行次数和输出语句的执行次数，那么当输入规模为 $n$ 时，以上算法执行的次数分别为

算法一 $:3$ 次
算法二 $:n+3$ 次
算法三 $:n^2+2$ 次

如果用大 $O$ 记法表示上述每个算法的时间复杂度，应该如何表示呢？基于我们对函数渐近增长的分析，推导大 $O$ 阶的表示法有以下几个规则可以使用

1.	用常数1取代运行时间中的所有加法常数
2.	在修改后的运行次数中, 只保留高阶项
3.	如果最高阶项存在, 且常数因子不为1, 则去除与这个项相乘的常数

所以，上述算法的大O记法分别为

​	算法一 $:O(1)$
​	算法二 $:O(n)$

